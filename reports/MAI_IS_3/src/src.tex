\section{Описание}

Изначально в качестве основы я решил сделать битовую матрицу вида id\_токена-id\_файла, где ID токена отвечает за номер строки в матрице, а ID файла отвечает за номер бита в этой строке.

ID токена и ID файла хранятся в дереве Patricia, которую я когда-то писал ещё в дискретном анализе, где в качестве ключа ставится сам токен и сам файл.

При добавлении нового токена в индекс, этому токену присваивается ID и он добавляется в соответствующее дерево. Аналогично с файлом. Если попадаются уже имеющиеся токены или файлы - они не добавляются в дерево.

Когда необходимо узнать, содержится ли токен в файле, сначала происходит поиск их ID и затем по ним берётся нужный бит. Если бит равен единице - токен есть в файле.

Однако ключевая проблема такой реализации - по мере увеличения масштабов, также значительно возрастают расходы на память. Допустим имеется уже в индексе 100 000 файлов. При добавлении нового токена придётся выделять память под новую строку длиной в 12 500 байт, что довольно много.

В добавок к этому сама битовая матрица получается разреженной и по сути довольно большое количество памяти расходуется в пустую.

Из-за этих причин я решил отказаться от этой идеи, хоть и сделал рабочую реализацию, в пользу обратного индекса.

В качестве основы я решил для начала сгруппировать всю полезную информацию по токену и файлу в отдельные структуры TTokenData и TFileData. 

TTokenData хранит в себе:
\begin{itemize}
    \item std::string - строка токена
    \item самописный динамический массив, хранящий указатели на те TFileData, где этот токен присутствует
    \item std::size\_t - ID
    \item std::size\_t - df (забегая вперёд)
\end{itemize}

TFileData хранит в себе:
\begin{itemize}
    \item std::string - название файла
    \item std::string - заголовок в файле (название статьи)
    \item дерево Patricia, в котором содержится количество токенов в файле. Там хранятся только те токены, что есть в файле, а не вообще все токены
    \item float score - для ранжирования
    \item std::size\_t - ID файла
\end{itemize}

Таким образом получая доступ к TTokenData, мы получаем доступ к соответствующим TFileData. Поэтому нет необходимости искать по названию файла нужный TFileData.

Затем использовал два дерева Patricia для сопоставления файлу и токену соответствующие TFileData и TTokenData.

Добавление в индекс сводилось к тому, чтобы добавлять новые токены и файлы в дерево и обновлять нужные существующие токены.

Что касается получения информации о том, в каких файлах содержится токен - всё сводится к поиску нужного TTokenData и возвращению массива указателей на TFileData.

Что касается сортировки, то в ней в моём случае не было необходимости - ID начисляются по возрастанию, поэтому списки уже получаются упорядоченными.

Касательно количества и размеров термов - они эквивалентны тому, что было в прошлых лабораторных работах, потому что полученные из них токены я применял в качестве термов. Возможно, я что-то упустил.

Загрузка 757,206 файлов и 141,154,824 токенов (из которых 3,434,138 уникальных) длилась ~10 минут. Скорее всего есть возможность ускорить загрузку индекса. Например, текущая реализация Patricia при вставке возвращает nullptr, если уже имеется подобный ключ, хотя можно возвращать ссылку на существующий элемент, и за счёт этого свести поиск по дереву к минимуму. 

Помимо этого на это ушло порядка ~17.5 Гб оперативной памяти, что по ощущению слишком много (сами файлы с токенами, не исходные, суммарно весят ~2.5 Гб).

\pagebreak

\section{Исходный код}
Битовая матрица - TBitTable.hpp:
\begin{lstlisting}[language=C++]
#ifndef T_BIT_TABLE_HPP
#define T_BIT_TABLE_HPP

#include <cstdlib>
#include <iostream>
#include <fstream>
#include <cstring>
#include "TPatriciaTrie.hpp"
#include "TFileData.hpp"

class TBitIndex {
    private:

        char**      bitTable;
        bool        check;
        std::size_t nBits;
        std::size_t nBytes;
        std::size_t allocBytes;

        std::size_t nTokens;
        std::size_t allocTokens;

        TPatriciaTrie<std::size_t> filenameToID;
        TPatriciaTrie<std::size_t> tokensToID;
        TPatriciaTrie<TFileData>   iDToFiledata;

        std::size_t BitsToBytes(std::size_t);

    public:

        TBitIndex();
        TBitIndex(std::size_t, std::size_t);
        TBitIndex(const TBitIndex&);

        ~TBitIndex();
        void Clear();
        void Init(std::size_t, std::size_t);

        std::size_t SizeInBytes();
        std::size_t SizeInBits();

        TFileData* GetFileDataByID(std::size_t);

        void Resize(std::size_t, std::size_t);

        void ReallocX();
        void ReallocY();
        void Realloc();

        void WriteToFile(std::string&);
        void Print();

        std::size_t Add(std::string&, int, TFileData&);

        TArray<std::string*> GetFileList();

        unsigned char BitSet(std::size_t, std::size_t, unsigned char);
        
        unsigned char BitGet(std::string&, std::string&);
        unsigned char BitGet(std::size_t, std::size_t);

        TBitIndex& operator= (const TBitIndex& table) {
            
            for(std::size_t i = 0; i < this->nTokens; ++i) {
                delete[] this->bitTable[i];
            }
            delete[] this->bitTable;
            

            this->allocBytes = table.allocBytes;
            this->allocTokens = table.allocTokens;
            this->nBytes = table.nBytes;
            this->nTokens = table.nTokens;
            this->nBits = table.nBits;

            this->bitTable = new char*[this->allocTokens];
            if(this->bitTable == nullptr) {
                std::cerr << "ERROR: malloc at TBitIndex::TBitIndex(const TBitIndex&)!" << std::endl;
            }
            for(std::size_t i = 0; i < this->nTokens; ++i) {
                this->bitTable[i] = new char[this->allocBytes];
            }

            for(std::size_t i = 0; i < this->nTokens; ++i) {
                for(std::size_t j = 0; j < this->nBytes; ++j) {
                    this->bitTable[i][j] = table.bitTable[i][j];
                }
            }

            return *this;
        }
};

#endif
\end{lstlisting}

Битовая матрица TBitTable.cpp:
\begin{lstlisting}[language=C++]
#include "TBitTable.hpp"

std::size_t TBitIndex::BitsToBytes(std::size_t nBits) {
    return ((nBits & 0x7) != 0) ? (nBits >> 3) + 1 : (nBits >> 3);
}

TBitIndex::TBitIndex() {
    this->nBits = 0;

    this->nBytes = 0;
    this->nTokens = 0;
    
    this->allocBytes = 0;
    this->allocTokens = 0;

    this->bitTable = nullptr;
}

TBitIndex::TBitIndex(std::size_t nTokens, std::size_t nFilenames) {
    this->nBits = nFilenames;

    this->nBytes = BitsToBytes(nFilenames);
    this->nTokens = nTokens;
    
    for(this->allocBytes = 1; this->allocBytes <= this->nBytes; this->allocBytes *= 2);
    for(this->allocTokens = 1; this->allocTokens <= this->nTokens; this->allocTokens *= 2);

    this->bitTable = new char*[this->allocTokens];
    for(std::size_t i = 0; i < this->allocTokens; ++i) {
        this->bitTable[i] = new char[this->allocBytes];
    }
}

TBitIndex::TBitIndex(const TBitIndex& table) {
    
    this->allocBytes = table.allocBytes;
    this->allocTokens = table.allocTokens;
    this->nBytes = table.nBytes;
    this->nTokens = table.nTokens;
    this->nBits = table.nBits;

    this->bitTable = new char*[this->allocTokens];
    if(this->bitTable == nullptr) {
        std::cerr << "ERROR: malloc at TBitTable::TBitTable(const TBitTable&)!" << std::endl;
    }
    for(std::size_t i = 0; i < this->nTokens; ++i) {
        this->bitTable[i] = new char[this->allocBytes];
    }

    for(std::size_t i = 0; i < this->nTokens; ++i) {
        for(std::size_t j = 0; j < this->nBytes; ++j) {
            this->bitTable[i][j] = table.bitTable[i][j];
        }
    }
}

TBitIndex::~TBitIndex() {
    if(this->bitTable) {
        for(std::size_t i = 0; i < this->allocTokens; ++i) {
            delete[] this->bitTable[i];
        }
        delete[] this->bitTable;
    }
}

void TBitIndex::Clear() {
    if(this->bitTable) {
        for(std::size_t i = 0; i < this->allocTokens; ++i) {
            if (this->bitTable[i]) {
                delete[] this->bitTable[i];
            }
        }
        delete[] this->bitTable;
    }

    this->nBits = 0;

    this->nBytes = 0;
    this->nTokens = 0;
    
    this->allocBytes = 0;
    this->allocTokens = 0;

    this->bitTable = nullptr;

}

void TBitIndex::Init(std::size_t nTokens, std::size_t nFilenames) {

    this->Clear();

    this->nBits = nFilenames;

    this->nBytes = BitsToBytes(nFilenames);
    this->nTokens = nTokens;
    
    for(this->allocBytes = 1; this->allocBytes <= this->nBytes; this->allocBytes *= 2);
    for(this->allocTokens = 1; this->allocTokens <= this->nTokens; this->allocTokens *= 2);

    this->bitTable = new char*[this->allocTokens];
    for(std::size_t i = 0; i < this->allocTokens; ++i) {
        this->bitTable[i] = new char[this->allocBytes];
    }
    return;
}

std::size_t TBitIndex::SizeInBytes() {
    return this->nBytes;
}

std::size_t TBitIndex::SizeInBits() {
    return this->nBits;
}

void TBitIndex::Realloc() {

    if (this->nBytes >= (this->allocBytes / 2)) {
        this->ReallocX();
    }

    if (this->nTokens >= (this->allocTokens / 2)) {
        this->ReallocY();
    }
}

void TBitIndex::ReallocY() {

    std::size_t prevAllocTokens = this->allocTokens;
    this->allocTokens = (this->allocTokens == 0) ? 2 : this->allocTokens * 2;

    char** newBitTable = new char*[this->allocTokens];
    if(newBitTable == nullptr) {
        std::cerr << "ERROR: new at TBitTable::ReallocY()!" << std::endl;
    }

    if(this->bitTable == nullptr) {
        for(std::size_t i = 0; i < this->allocTokens; ++i) {
            
            newBitTable[i] = new char[this->allocBytes];
            if(newBitTable[i] == nullptr) {
                std::cerr << "ERROR: new at TBitTable::ReallocY()!" << std::endl;
            }

            for(std::size_t j = 0; j < this->allocBytes; ++j) {
                newBitTable[i][j] = 0;
            }
        }
    }
    else {
        
        for(std::size_t i = 0; i < prevAllocTokens; ++i) {
            newBitTable[i] = this->bitTable[i];
        }
        for(std::size_t i = prevAllocTokens; i < this->allocTokens; ++i) {
            
            newBitTable[i] = new char[this->allocBytes];
            if(newBitTable[i] == nullptr) {
                std::cerr << "ERROR: new at TBitTable::ReallocY()!" << std::endl;
            }

            for(std::size_t j = 0; j < this->allocBytes; ++j) {
                newBitTable[i][j] = 0;
            }
        }

        delete[] this->bitTable;
    }

    this->bitTable = newBitTable;
    return;
}

void TBitIndex::ReallocX() {

    std::size_t prevAllocBytes  = this->allocBytes;
    this->allocBytes            = (this->allocBytes == 0) ? 2 : this->allocBytes * 2;

    if(this->bitTable == nullptr) {
        return;
    }
    
    for(std::size_t i = 0; i < this->allocTokens; ++i) {
        char* newLine = new char[this->allocBytes];
        if(newLine == nullptr) {
            std::cerr << "ERROR: new at TArray::reallocArray()!" << std::endl;
        }

        for(std::size_t j = 0; j < prevAllocBytes; ++j) {
            newLine[j] = this->bitTable[i][j];
        }
        for(std::size_t j = prevAllocBytes; j < this->allocBytes; ++j) {
            newLine[j] = 0;
        }

        delete[] this->bitTable[i];
        this->bitTable[i] = newLine;
    }
    
    return;
}

TFileData* TBitIndex::GetFileDataByID(std::size_t id) {
    std::string strID = std::to_string(id);
    return this->iDToFiledata.Lookup(strID);
}

std::size_t TBitIndex::Add(std::string& token, int count, TFileData& filedata) {

    std::size_t i = 0;
    std::size_t j = 0;

    if(this->filenameToID.Insert(filedata.filepath, this->nBits) != nullptr) {
        j = this->nBits;
        std::string id = std::to_string(this->nBits);
        this->iDToFiledata.Insert(id, filedata);
        ++(this->nBits);
        this->nBytes = BitsToBytes(this->nBits);
    }
    else {
        j = *(this->filenameToID.Lookup(filedata.filepath));
    }

    if(this->tokensToID.Insert(token, this->nTokens) != nullptr) {
        i = this->nTokens;
        ++(this->nTokens);
    }
    else {
        i = *(this->tokensToID.Lookup(token));
    }

    this->Realloc();

    this->BitSet(i, j, 1);
    return 0;
}

void TBitIndex::Print() {
    TArray<std::string*> tokenList = this->tokensToID.KeyList();
    TArray<std::string*> fileList  = this->filenameToID.KeyList();
    for(std::size_t i = 0; i < tokenList.Size(); ++i) {
        std::cout << "Token: " << *tokenList[i] << " | Table: ";
        for(std::size_t j = 0; j < fileList.Size(); ++j) {
            std::cout << (int) this->BitGet(i, j);
            if (j % 8 == 0 && j > 0) {
                std::cout << " ";
            }
        }
        std::cout << std::endl;
    }
}

void TBitIndex::WriteToFile(std::string& filename) {

    std::fstream file(filename, std::ios::out);

    TArray<std::string*> tokenList = this->tokensToID.KeyList();
    TArray<std::string*> fileList = this->filenameToID.KeyList();
    for(std::size_t i = 0; i < tokenList.Size(); ++i) {
        file << "| Token: " << *tokenList[i] << std::endl << "| Table:";
        for(std::size_t j = 0; j < fileList.Size(); ++j) {
            file << (int) this->BitGet(i, j);
            if (j % 8 == 0 && j > 0) {
                file << " ";
            }
        }
        file << std::endl;
        file << "=======" << std::endl;
    }

    file << std::endl;

    for(std::size_t j = 0; j < fileList.Size(); ++j) {
        file << j << ": " << *fileList[j] << std::endl;
    }

    file.close();

    return;
}

TArray<std::string*> TBitIndex::GetFileList() {
    return TArray(this->filenameToID.KeyList());
}

unsigned char TBitIndex::BitGet(std::size_t i, std::size_t j) {
    if (j >= this->nBits || i >= this->nTokens) {
        std::cerr << "ERROR: out of border in TBitIndex::BitGet(std::size_t, std::size_t)!" << std::endl;
        return 2;
    }
    int k = (j & 0x7);
    return ( (*(this->bitTable[i] + (j >> 3))) >> k) & 0x01;
}

unsigned char TBitIndex::BitGet(std::string& token, std::string& filename) {
    
    std::size_t i = *(this->tokensToID.Lookup(token));
    std::size_t j = *(this->filenameToID.Lookup(filename));

    return this->BitGet(i, j);
}

unsigned char TBitIndex::BitSet(std::size_t i, std::size_t j, unsigned char value) {
    if (j >= this->nBits || i >= this->nTokens) {
        std::cerr << "ERROR: out of border in TBitIndex::BitSet(std::size_t, std::size_t, unsigned char)!" << std::endl;
        return 2;
    }

    int k = (j & 0x7);
    int byte = j >> 3;

    if (value) {
        *(this->bitTable[i] + byte) = *(this->bitTable[i] + byte) | 0x01 << k;
    }
    else {
        *(this->bitTable[i] + byte) = *(this->bitTable[i] + byte) & ~(0x01 << k);
    }
    
    return 0;
}

\end{lstlisting}

Данные по файлу - TFileData.hpp:
\begin{lstlisting}[language=C++]
#ifndef T_FILE_DATA
#define T_FILE_DATA

#include <iostream>
#include <string>
#include "TPatriciaTrie.hpp"

class TFileData {
    public:
        std::string         filepath;
        std::string         title;
        TPatriciaTrie<int>  tokenToTF;
        float               score;
        std::size_t         id;

        TFileData();
        TFileData(TFileData&);
        TFileData(std::string, std::string, std::size_t);
        ~TFileData();

        friend std::ostream& operator << (std::ostream&, TFileData&);

        TFileData&     operator= (const TFileData& data) {
            
            this->filepath  = data.filepath;
            this->title     = data.title;
            this->tokenToTF = data.tokenToTF;
            this->score     = data.score;
            this->id        = data.id;

            return *this;
        }
};

#endif
\end{lstlisting}

Данные по файлу - TFileData.cpp:
\begin{lstlisting}[language=C++]
#include "TFileData.hpp"

TFileData::TFileData(): filepath(), title(), tokenToTF() {
    this->score     = 0;
    this->id        = 0;
};

TFileData::~TFileData() {};

TFileData::TFileData(TFileData& toCopy) {
    this->filepath  = toCopy.filepath;
    this->title     = toCopy.title;
    this->tokenToTF = toCopy.tokenToTF;
    this->score     = toCopy.score;
    this->id        = toCopy.id;
}

TFileData::TFileData(std::string filepath, std::string title, std::size_t id): tokenToTF() {
    this->filepath  = filepath;
    this->title     = title;
    this->score     = 0.0;
    this->id        = id;
}

std::ostream& operator<<(std::ostream& os, TFileData& fileData) {
    os << "Filepath: " << fileData.filepath << std::endl;
    os << "Title: " << fileData.title << std::endl;
    os << "Score: " << fileData.score << std::endl;
    return os;
}
\end{lstlisting}

Данные по токену - TTokenData.hpp:
\begin{lstlisting}[language=C++]
#ifndef T_TOKEN_DATA
#define T_TOKEN_DATA

#include <iostream>
#include <string>
#include "TPatriciaTrie.hpp"
#include "TArray.hpp"
#include "TFileData.hpp"

class TTokenData {
    public:
        std::string         token;
        TArray<TFileData*>  files;
        std::size_t         df;
        std::size_t         id;

        TTokenData();
        TTokenData(TTokenData&);
        TTokenData(std::string);
        ~TTokenData();

        friend std::ostream& operator << (std::ostream&, TTokenData&);

        TTokenData&     operator= (const TTokenData& data) {
            
            this->token = data.token;
            this->files = data.files;
            this->df    = data.df;
            this->id    = data.id;

            return *this;
        }
};

#endif
\end{lstlisting}

Данные по токену - TTokenData.cpp:
\begin{lstlisting}[language=C++]
#include "TTokenData.hpp"

TTokenData::TTokenData(): files() {
    this->token = "";
    this->df    = 0;
    this->id    = 0;
};

TTokenData::~TTokenData() {};

TTokenData::TTokenData(TTokenData& toCopy) {
    this->token  = toCopy.token;
    this->files  = toCopy.files;
    this->df     = toCopy.df;
    this->id     = toCopy.id;
}

TTokenData::TTokenData(std::string token): files() {
    this->token  = token;
    this->df     = 0;
    this->id     = 0;
}

std::ostream& operator<<(std::ostream& os, TTokenData& tokenData) {
    os << "Token: " << tokenData.token << std::endl;
    return os;
}
\end{lstlisting}

Обратный индекс - TRevIndex.hpp:
\begin{lstlisting}[language=C++]
#ifndef T_REV_INDEX_HPP
#define T_REV_INDEX_HPP

#include <cstdlib>
#include <iostream>
#include <cstring>
#include <string>
#include <unistd.h>
#include <cmath>
#include "TPatriciaTrie.hpp"
#include "TArray.hpp"
#include "TFileData.hpp"
#include "TTokenData.hpp"

class TRevIndex {
    private:

        TPatriciaTrie<TTokenData>  tokenToTokenData;
        TPatriciaTrie<TFileData>   filenameToFileData;

    public:

        TRevIndex();
        ~TRevIndex();

        void Print();

        TArray<TFileData*>   IDToFileData(TArray<std::size_t>&);

        std::size_t          Add(TTokenData&, int, TFileData&);

        TArray<TFileData*>   GetArray(std::string&);

        TTokenData*          GetTokenData(std::string&);
        TFileData*           GetFileData(std::string&);

        void                 CalcTFxIDF(TArray<TTokenData*>&, TArray<TFileData*>&);
};

#endif
\end{lstlisting}

Обратный индекс - TRevIndex.cpp:
\begin{lstlisting}[language=C++]
#include "TRevIndex.hpp"

TRevIndex::TRevIndex(): tokenToTokenData(), filenameToFileData() {};

TRevIndex::~TRevIndex() {};

std::size_t TRevIndex::Add(TTokenData& tokenData, int count, TFileData& filedata) {

    filedata.id = this->filenameToFileData.Size();
    tokenData.id = this->tokenToTokenData.Size();

    TPatriciaTrieItem<TTokenData>* tData = this->tokenToTokenData.Insert(tokenData.token, tokenData);
    if(tData != nullptr) {
        tData->GetData()->df = 1;
    }
    else {
        tData = this->tokenToTokenData.LookupNode(tokenData.token);
        tData->GetData()->df += 1;
    }

    TPatriciaTrieItem<TFileData>* fData = this->filenameToFileData.Insert(filedata.filepath, filedata);
    if(fData == nullptr) {
        fData = this->filenameToFileData.LookupNode(filedata.filepath);
    }

    std::string tokenID = std::to_string(tData->GetData()->id);

    fData->GetData()->tokenToTF.Insert(tokenID, count);
    tData->GetData()->files.Push(fData->GetData());

    return 0;
}

TTokenData* TRevIndex::GetTokenData(std::string& token) {
    return this->tokenToTokenData.Lookup(token);
}

TFileData* TRevIndex::GetFileData(std::string& filename) {
    return this->filenameToFileData.Lookup(filename);
}

void TRevIndex::CalcTFxIDF(TArray<TTokenData*>& tokenList, TArray<TFileData*>& filesList) {

    std::size_t tokenSum = tokenList.Size();
    std::size_t fileSum  = filesList.Size();

    for (std::size_t fileID = 0; fileID < fileSum; ++fileID) {

        float score = 0.0;

        for (std::size_t tokenID = 0; tokenID < tokenSum; ++tokenID) {
            
            std::string id = std::to_string(tokenList[tokenID]->id);

            int* ptrTf = filesList[fileID]->tokenToTF.Lookup(id);
            float weightTf = (ptrTf == nullptr) ? 0.0 : (1 + std::log10((float) *ptrTf));
            
            float df = this->tokenToTokenData[tokenList[tokenID]->token].df;
            float weightDf = std::log10((float) this->filenameToFileData.Size() / df);

            score += weightTf * weightDf;

        }
        
        filesList[fileID]->score = score;
    }
}

TArray<TFileData*> TRevIndex::GetArray(std::string& token) {
    TTokenData* tokenData = this->tokenToTokenData.Lookup(token);
    return (tokenData == nullptr) ? TArray<TFileData*>() : TArray<TFileData*>(tokenData->files);
}

void TRevIndex::Print() {

    TArray<std::string*> tokenList = this->tokenToTokenData.KeyList();
    std::size_t tSize = tokenList.Size();

    for(std::size_t tokenID = 0; tokenID < tSize; ++tokenID) {
        
        TTokenData* tokenData = this->tokenToTokenData.Lookup(*tokenList[tokenID]);
        std::size_t fSize = tokenData->files.Size();

        std::cout << "Token: " << tokenData->token << std::endl;
        std::cout << "Files: ";

        for(std::size_t fileID = 0; fileID < fSize; ++fileID) {

            TFileData* fileData = tokenData->files[fileID];

            std::cout << fileData->filepath << ":" << fileData->title << " | ";
        }

        std::cout << std::endl;
    }
    
    return;
}
\end{lstlisting}

Динамический массив - TArray.hpp:
\begin{lstlisting}[language=C++]
#ifndef T_TARRAY_HPP
#define T_TARRAY_HPP

#include <iostream>
#include <cstdlib>

template <typename T>
class TArray;

template <typename T>
std::ostream& operator<<(std::ostream& os, const TArray<T>& array) {
    for(std::size_t i = 0; i < array.n; ++i) {
        os << array.data[i] << std::endl;
    }
    return os;
}

template <typename T>
class TArray {
    private:

        T** data;
        std::size_t n;
        std::size_t s;

        void ReallocArray();

    public:

        TArray();
        TArray(const TArray&);
        TArray(std::size_t);
        ~TArray();

        void            Clear();

        bool            IsEmpty();

        std::size_t     Size();
        void            Push(T);
        T               Pop();
        int             Remove(std::size_t);

        void            Print();

        T               Get(std::size_t);

                T&  operator[] (std::size_t i)       { 
            return *this->data[i]; 
        }

        const   T&  operator[] (std::size_t i) const { 
            return *this->data[i]; 
        }

        TArray<T>&     operator= (const TArray<T>& arr)    {
            
            for(std::size_t i = 0; i < this->n; ++i) {
                delete this->data[i];
            }
            delete[] this->data;

            this->n = arr.n;
            this->s = arr.s;

            this->data = new T*[this->s];
            if(this->data == nullptr) {
                std::cerr << "ERROR: malloc at TArray::TArray(const TArray&)!" << std::endl;
            }
            for(std::size_t i = 0; i < this->n; ++i) {
                this->data[i] = new T;
                *this->data[i] = *arr.data[i];
            }

            return *this;
        }
        
        friend std::ostream& operator<< <>(std::ostream&, const TArray<T>&);
};

#endif
\end{lstlisting}

Динамический массив - TArray.cpp:
\begin{lstlisting}[language=C++]
#include "TArray.hpp"

template <typename T>
void TArray<T>::ReallocArray() {
        T** newAlloc = new T*[this->s];
        if(newAlloc == nullptr) {
            std::cerr << "ERROR: new at TArray::reallocArray()!" << std::endl;
        }
        for(std::size_t i = 0; i < this->n; ++i) {
            newAlloc[i] = this->data[i];
        }
        delete[] this->data;
        this->data = newAlloc;
}

template <typename T>
TArray<T>::TArray() {
    this->data  = new T*[1];
    if(this->data == nullptr) {
        std::cerr << "ERROR: malloc at TArray::TArray()!" << std::endl;
    }
    this->n = 0;
    this->s = 1;
}

template <typename T>
TArray<T>::TArray(std::size_t size) {
    this->data  = new T*[size];
    if(this->data == nullptr) {
        std::cerr << "ERROR: malloc at TArray::TArray()!" << std::endl;
    }
    for(std::size_t i = 0; i < size; ++i) {
        this->data[i] = new T();
    }

    this->n = size;
    this->s = 1;
    for(;this->s < this->n; this->s *= 2);
}

template <typename T>
TArray<T>::TArray(const TArray& arr) {
    this->n = arr.n;
    this->s = arr.s;

    this->data = new T*[this->s];
    if(this->data == nullptr) {
        std::cerr << "ERROR: malloc at TArray::TArray(const TArray&)!" << std::endl;
    }
    for(std::size_t i = 0; i < this->n; ++i) {
        this->data[i] = new T();
        *this->data[i] = *arr.data[i];
    }
}

template <typename T>
TArray<T>::~TArray() {
    for(std::size_t i = 0; i < this->n; ++i) {
        delete this->data[i];
    }
    delete[] this->data;
}

template <typename T>
void TArray<T>::Clear() {
    for(std::size_t i = 0; i < this->n; ++i) {
        delete this->data[i];
    }
    delete[] this->data;

    this->data = new T*[1];
    if(this->data == nullptr) {
        std::cerr << "ERROR: malloc at TArray::Clear()!" << std::endl;
    }
    this->n = 0;
    this->s = 1;
    return;
}

template <typename T>
std::size_t TArray<T>::Size() {
    return this->n;
}

template <typename T>
void TArray<T>::Push(T item) {

    this->data[this->n]  = new T;
    if(this->data[this->n] == nullptr) {
        std::cerr << "ERROR: new at TArray::push()!" << std::endl;
    }
    *this->data[n] = item;

    ++(this->n);

    if (this->n >= (this->s / 2)) {
        this->s *= 2;
        this->ReallocArray();
    }

    return;
}

template <typename T>
T TArray<T>::Pop() {
    
    if (this->s == 1) {
        std::cerr << "ERROR: Array is empty, but pop() called!" << std::endl;
        return T();
    }

    T* ptrData = this->data[n - 1];
    T poppedData = *ptrData;

    delete this->data[n - 1];

    --(this->n);

    if (this->n < (this->s / 2)) {
        this->s /= 2;
        this->ReallocArray();
    }

    return poppedData;
}
template <typename T>
bool TArray<T>::IsEmpty() {
    return (this->n == 0) ? true : false;
}

template <typename T>
int TArray<T>::Remove(std::size_t pos) {

    if (this->s == 1) {
        std::cerr << "ERROR: Array is empty, but remove() called!" << std::endl;
        return 1;
    }

    if (pos >= this->n || pos < 0) {
        std::cerr << "ERROR: Certain position is of array!" << std::endl;
        return 2;
    }

    delete this->data[pos];

    for(std::size_t i = pos; i < this->n; ++i) {
        this->data[i] = this->data[i + 1];
    }

    --(this->n);

    if (this->n < (this->s / 2)) {
        this->s /= 2;
        this->ReallocArray();
    }

    return 0;
}

template <typename T>
void TArray<T>::Print() {
    for(std::size_t i = 0; i < this->n; ++i) {
        std::cout << *this->data[i] << std::endl;
    }
    return;
}

template <typename T>
T TArray<T>::Get(std::size_t i) {
    if (i >= this->n || i < 0) {
        return T();
    }

    return *this->data[i];
}

template class TArray<std::string>;
template class TArray<std::size_t>;
template class TArray<TArray<std::size_t>>;
template class TArray<std::string*>;

#include "TPatriciaTrieItem.hpp"
template class TArray<TPatriciaTrieItem<std::size_t>*>;
template class TArray<TPatriciaTrieItem<std::string>*>;
template class TArray<TPatriciaTrieItem<int>*>;

#include "TFileData.hpp"
template class TArray<TFileData>;
template class TArray<TFileData*>;
template class TArray<TPatriciaTrieItem<TFileData>*>;

#include "TTokenData.hpp"
template class TArray<TTokenData>;
template class TArray<TTokenData*>;
template class TArray<TPatriciaTrieItem<TTokenData>*>;
\end{lstlisting}

Дерево Patricia - TPatriciaTrie.hpp:
\begin{lstlisting}[language=C++]
#ifndef T_PATRICIA_TRIE_ITEM_HPP
#define T_PATRICIA_TRIE_ITEM_HPP

#include "TPatriciaTrieItem.hpp"
#include "TArray.hpp"
#include <string>
#include <fstream>

template <class T>
class TPatriciaTrie {
    private:
        
        struct TPack {
            char                    up;
            int                     length;
            T                       data;
            int                     index;
        };

        void                    RecursiveRemove(TPatriciaTrieItem<T>*);
        int                     BitGet(const char*, int) const;
        int                     BitFirstDifferent(const char*, const char*) const;
        bool                    KeyCompare(const char*, const char*) const;
        void                    KeyCopy(TPatriciaTrieItem<T>*, TPatriciaTrieItem<T>*);
        
        TPatriciaTrieItem<T>*   head;
        std::size_t             size;

    public:

        TPatriciaTrie();
        TPatriciaTrie(TPatriciaTrie<T>&);

        virtual ~TPatriciaTrie();
        
        TPatriciaTrieItem<T>*   LookupNode(std::string&) const;
        T*                      Lookup(std::string&) const;
        TPatriciaTrieItem<T>*   Insert(std::string&, T&);
        bool                    Delete(std::string&);
        
        TArray<std::string*>    KeyList() const;
        std::size_t             Size() const;

        TPatriciaTrieItem<T>*   GetHead() const;
        void                    Print(TPatriciaTrieItem<T>*, int) const;
        void                    Print() const;
        void                    ClearTrie();
        bool                    Empty() const;
        void                    SwapHead(TPatriciaTrie<T>*);
        
        bool                    SaveTrieBefore(TPatriciaTrieItem<T>*, std::ofstream*) const;
        bool                    SaveTrieCurrent(TPatriciaTrieItem<T>*, std::ofstream*) const;
        
        void                    LoadTrieBefore(std::string&, std::ifstream*);
        void                    LoadTrieCurrent(std::string&, TPatriciaTrieItem<T>*, std::ifstream*);

        TArray<TPatriciaTrieItem<T>*> ItemList() const;

        TPatriciaTrie<T>& operator= (const TPatriciaTrie<T>& trie) {
            
            this->ClearTrie();

            TArray<TPatriciaTrieItem<T>*> items = trie.ItemList();
            
            for (std::size_t i = 0; i < items.Size(); ++i) {
                this->Insert(items[i]->key, items[i]->data);
            }

            return *this;
        };

                T&  operator[] (std::string key)       {
            return *this->Lookup(key);
        };
};

#endif
\end{lstlisting}

Дерево Patricia - TPatriciaTrie.cpp:
\begin{lstlisting}[language=C++]
#include "TPatriciaTrie.hpp"
#include <stdlib.h>
#include <iostream>
#include <cstring>

const int MAX_DEEP = 10;

//----------------------------------------------------------------------------
template <class T>
TPatriciaTrie<T>::TPatriciaTrie() {
    head = new TPatriciaTrieItem<T>();
    if(!head) {
        std::cout << "ERROR: bad allocation!" << std::endl;
        exit(0);
    }
    head->key = "";
    head->key.reserve(256);
    size = 0;
}

//----------------------------------------------------------------------------

template <class T>
TPatriciaTrie<T>::TPatriciaTrie(TPatriciaTrie<T>& toCopy) {
    head = new TPatriciaTrieItem<T>();
    if(!head) {
        std::cout << "ERROR: bad allocation!" << std::endl;
        exit(0);
    }
    head->key = "";
    head->key.reserve(256);
    size = 0;

    TArray<TPatriciaTrieItem<T>*> items = toCopy.ItemList();

    for(std::size_t i = 0; i < items.Size(); ++i) {
        this->Insert(items[i]->key, items[i]->data);
    }
}

//----------------------------------------------------------------------------
template <class T>
TPatriciaTrie<T>::~TPatriciaTrie() {
    RecursiveRemove(head);
}

//----------------------------------------------------------------------------
template <class T>
std::size_t TPatriciaTrie<T>::Size() const {
    return size;
}

//----------------------------------------------------------------------------
template <class T>
TPatriciaTrieItem<T>* TPatriciaTrie<T>::Insert(std::string& key, T& data) {
    
    int                     bitIndex;
    TPatriciaTrieItem<T>*   tmp;
    TPatriciaTrieItem<T>*   prev = head;
    TPatriciaTrieItem<T>*   directNode = head->right;
    
    while (prev->index < directNode->index) {
        prev = directNode;
        directNode = (BitGet(key.c_str(), directNode->index)) ? directNode->right : directNode->left;
    }
    
    
    
    if (KeyCompare(key.c_str(), directNode->key.c_str())) {
        return nullptr;
    }
    
    bitIndex = BitFirstDifferent(key.c_str(), directNode->key.c_str());
    
    prev = head;
    tmp = head->right;
    
    while ( (prev->index < tmp->index) && (tmp->index < bitIndex) ) {
        prev = tmp;
        tmp = BitGet(key.c_str(), tmp->index) ? tmp->right : tmp->left;
    }
    
    TPatriciaTrieItem<T>* newNode = new TPatriciaTrieItem<T>();
    if(!newNode) {
        std::cout << "ERROR: bad allocation!" << std::endl;
        exit(0);
    }
    
    newNode->Initialize(key, data, bitIndex, BitGet(key.c_str(), bitIndex) ? tmp : newNode, BitGet(key.c_str(), bitIndex) ? newNode : tmp);        
    
    if(BitGet(key.c_str(), prev->index)) {
        prev->right = newNode;
    }
    else {
        prev->left = newNode;
    }
    ++size;
    return newNode;
    
}
//----------------------------------------------------------------------------
template <class T>
void TPatriciaTrie<T>::Print() const {
    return this->Print(this->head, 0);
}
//----------------------------------------------------------------------------
template <class T>
void TPatriciaTrie<T>::Print(TPatriciaTrieItem<T>* root, int deep) const {
    
    int pDeep;
    
    if ( root->index < root->left->index ) {
        Print(root->left, deep + 1);
    }
    // else {
    //     for(int i = 0; i < deep + 1; ++i) {
    //         std::cout << "|\t";
    //     }
    //     std::cout << root->left->data;
    //     pDeep = deep + 1;
    //     while(pDeep < MAX_DEEP) {
    //         ++pDeep;
    //         std::cout << "\t|";
    //     }
    //     std::cout << std::endl;
    // }
    
    for(int i = 0; i < deep; ++i) {
        std::cout << "|\t";
    }
    std::cout << root->key << ':' << root->data;
    pDeep = deep;
    while(pDeep < MAX_DEEP) {
        ++pDeep;
        std::cout << "\t|";
    }
    std::cout << std::endl;

    if ( root->index < root->right->index ) {
        Print(root->right, deep + 1);
    }
    // else {
    //     for(int i = 0; i < deep + 1; ++i) {
    //         std::cout << "|\t";
    //     }
    //     std::cout << root->right->data;
    //     pDeep = deep + 1;
    //     while(pDeep < MAX_DEEP) {
    //         ++pDeep;
    //         std::cout << "\t|";
    //     }
    //     std::cout << std::endl;
    // }
}

//----------------------------------------------------------------------------
template <class T>
bool TPatriciaTrie<T>::SaveTrieBefore(TPatriciaTrieItem<T>* root, std::ofstream* file) const {
    
    int length = 0;
    
    if( head->right == head) {
        return true;
    }
    
    length = root->key.length();
    file->write((char*)&length, sizeof(int));
    file->write(root->key.c_str(), sizeof(char)*length);
    file->write((char*)&root->data, sizeof(T));
    
    if ( root->index < root->left->index ) {
        if(!SaveTrieBefore(root->left, file)) {
            return false;
        }
    }

    if ( root->index < root->right->index ) {
        if(!SaveTrieBefore(root->right, file)) {
            return false;
        }
    }
    
    return true;
}

//----------------------------------------------------------------------------
template <class T>
void TPatriciaTrie<T>::LoadTrieBefore(std::string& key, std::ifstream* file) {
    
    T data = T();
    int length = 0;
    char buffer[256];

    while(!file->eof()) {
        file->read((char*)&length,sizeof(int));
        file->read(buffer, length*sizeof(char));
        key = buffer;
        file->read((char*)&data,sizeof(T));
        
        Insert(key, data);
    }
    
}

//----------------------------------------------------------------------------

template <class T>
bool TPatriciaTrie<T>::SaveTrieCurrent(TPatriciaTrieItem<T>* root, std::ofstream* file) const {
    
    TPatriciaTrie<T>::TPack   pack;
    char                      check;
    
    if( head->right == head ) {
        check = 1;
        file->write(&check, sizeof(char));
        return true;
    }
    else if( head == root ) {
        check = 0;
        pack.up = 0;
        pack.length = root->right->key.length();
        pack.index = root->right->index;
        pack.data = root->right->data;
        file->write(&check, sizeof(char));
        file->write((char*)&pack, sizeof(TPatriciaTrie<T>::TPack));
        file->write(root->right->key.c_str(), sizeof(char)*pack.length);
        return SaveTrieCurrent(root->right, file);
    }
    
    pack.up = ( root->index < root->left->index ) ? 0 : 1;
    pack.length = root->left->key.length();
    if(!pack.up) {
        pack.index = root->left->index;
        pack.data = root->left->data;
    }
    file->write((char*)&pack, sizeof(TPatriciaTrie<T>::TPack));
    file->write(root->left->key.c_str(), sizeof(char)*pack.length);
    
    pack.up = ( root->index < root->right->index ) ? 0 : 1;
    pack.length = root->right->key.length();
    if(!pack.up) {
        pack.index = root->right->index;
        pack.data = root->right->data;
    }
    file->write((char*)&pack, sizeof(TPatriciaTrie<T>::TPack));
    file->write(root->right->key.c_str(), sizeof(char)*pack.length);
    
    if ( root->index < root->left->index ) {
        SaveTrieCurrent(root->left, file);
    }

    if ( root->index < root->right->index ) {
        SaveTrieCurrent(root->right, file);
    }
    
    return true;
}

//----------------------------------------------------------------------------
template<class T>
void TPatriciaTrie<T>::LoadTrieCurrent(std::string& key, TPatriciaTrieItem<T>* root, std::ifstream* file) {
    
    TPatriciaTrie<T>::TPack   pack;
    char                      check;
    char                      buffer[256];

    if( head == root ) {
        file->read(&check, sizeof(char));
        if(check) {
            return;
        }
        file->read((char*)&pack,sizeof(TPatriciaTrie<T>::TPack));
        file->read(buffer, pack.length*sizeof(char));
        key = buffer;
        TPatriciaTrieItem<T>* newNode = new TPatriciaTrieItem<T>();
        if(!newNode) {
            std::cout << "ERROR: bad allocation!" << std::endl;
            exit(0);
        }
        newNode->Initialize(key, pack.data, pack.index, newNode, newNode);
        head->right = newNode;
        return LoadTrieCurrent(key, head->right, file);
    }
    else {
        file->read((char*)&pack,sizeof(TPatriciaTrie<T>::TPack));
        file->read(buffer, pack.length*sizeof(char));
        key = buffer;
        if(!pack.up) {
            TPatriciaTrieItem<T>* newNode = new TPatriciaTrieItem<T>();
            if(!newNode) {
                std::cout << "ERROR: bad allocation!" << std::endl;
                exit(0);
            }
            newNode->Initialize(key, pack.data, pack.index, newNode, newNode);
            root->left = newNode;
        }
        else {
            TPatriciaTrieItem<T>* current = head;
            while(current->key != key) {
                current = (BitGet(key.c_str(), current->index)) ? current->right : current->left;
            }
            root->left = current;
        }
        
        file->read((char*)&pack,sizeof(TPatriciaTrie<T>::TPack));
        file->read(buffer, pack.length*sizeof(char));
        key = buffer;
        if(!pack.up) {
            TPatriciaTrieItem<T>* newNode = new TPatriciaTrieItem<T>();
            if(!newNode) {
                std::cout << "ERROR: bad allocation!" << std::endl;
                exit(0);
            }
            newNode->Initialize(key, pack.data, pack.index, newNode, newNode);
            root->right = newNode;
        }
        else {
            TPatriciaTrieItem<T>* current = head;
            while(current->key != key) {
                current = (BitGet(key.c_str(), current->index)) ? current->right : current->left;
            }
            root->right = current;
        }
        
        if ( root->index < root->left->index ) {
            LoadTrieCurrent(key, root->left, file);
        }

        if ( root->index < root->right->index ) {
            LoadTrieCurrent(key, root->right, file);
        }
        
        return;
    }
}

//----------------------------------------------------------------------------
template <class T>
T* TPatriciaTrie<T>::Lookup(std::string& k) const {

    TPatriciaTrieItem<T>* node = LookupNode(k);

    if (!node) {
        return nullptr;
    }

    return &(node->data);

}

//----------------------------------------------------------------------------
template <class T>
TPatriciaTrieItem<T>* TPatriciaTrie<T>::LookupNode(std::string& key) const {
    
    TPatriciaTrieItem<T>*   prev = head;
    TPatriciaTrieItem<T>*   directNode = head->right;
    
    while( prev->index < directNode->index ) {
        prev = directNode;
        directNode = BitGet(key.c_str(), directNode->index) ? directNode->right : directNode->left;
    }
    
    if (!KeyCompare(key.c_str(), directNode->key.c_str())) {
        return nullptr;
    }

    return directNode;

}

//----------------------------------------------------------------------------
template <class T>
bool TPatriciaTrie<T>::Delete(std::string& key) {
    
    TPatriciaTrieItem<T> *path[2], *directNode, *x, *lp;

    path[1]     = head;
    directNode  = head->right;

    while (path[1]->index < directNode->index) {
        path[0]     = path[1];
        path[1]     = directNode;
        directNode  = BitGet(key.c_str(), directNode->index) ? directNode->right : directNode->left;
    }
    
    if (!KeyCompare(key.c_str(), directNode->key.c_str())) {
        return false;
    }

    if (directNode != path[1])
        KeyCopy(path[1], directNode);

    if ((path[1]->left->index > path[1]->index) || (path[1]->right->index > path[1]->index)) {

        if (path[1] != directNode) {

            lp = path[1];
            x  = BitGet(path[1]->key.c_str(), path[1]->index) ? path[1]->right : path[1]->left;
 
            while (lp->index < x->index) {
                lp = x;
                x  = BitGet(path[1]->key.c_str(), x->index) ? x->right : x->left;
            }

            if (!KeyCompare(path[1]->key.c_str(), x->key.c_str())) {
                return false;
            }

            if (BitGet(path[1]->key.c_str(), lp->index)) {
                lp->right = directNode;
            }
            else {
                lp->left  = directNode;
            }
        }

        if (path[0] != path[1]) {
            TPatriciaTrieItem<T>* child = BitGet(key.c_str(), path[1]->index) ? path[1]->left : path[1]->right;
            if (BitGet(key.c_str(), path[0]->index)) {
                path[0]->right = child;
            }
            else {
                path[0]->left  = child;
            }
        }
   
    }
    else if (path[0] != path[1]) {
        TPatriciaTrieItem<T>* cLeft = path[1]->left;
        TPatriciaTrieItem<T>* cRight = path[1]->right;
        if (BitGet(key.c_str(), path[0]->index)) {
            path[0]->right = (((cLeft == cRight) && (cLeft == path[1])) ? path[0] : ((cLeft==path[1]) ? cRight : cLeft ));
        }
        else {
            path[0]->left  = (((cLeft == cRight) && (cLeft == path[1])) ? path[0] : ((cLeft==path[1]) ? cRight : cLeft ));
        }
    }

    --size;
    delete path[1];

    return true;
}

//----------------------------------------------------------------------------
template <class T>
void TPatriciaTrie<T>::RecursiveRemove(TPatriciaTrieItem<T>* root) {

    TPatriciaTrieItem<T>* l = root->left;
    TPatriciaTrieItem<T>* r = root->right;

    if ( (l->index >= root->index) && (l != root) && (l != head) )
        RecursiveRemove(l);

    if ( (r->index >= root->index) && (r != root) && (r != head) )
        RecursiveRemove(r);

    delete root;

}

//----------------------------------------------------------------------------
template <class T>
void TPatriciaTrie<T>::ClearTrie() {
    if (head->right != head) {
        RecursiveRemove(head->right);
        head->right = head;
        size = 0;
    }
    return;
}

//----------------------------------------------------------------------------
template <class T>
bool TPatriciaTrie<T>::Empty() const {
    if( head->right == head ) {
        return true;
    }
    else {
        return false;
    }
}
//----------------------------------------------------------------------------
template <class T>
int TPatriciaTrie<T>::BitGet(const char* bit_stream, int n) const {
    if (n == -1) {
        return 2;
    }
    int k = (n & 0x7);
    return ( (*(bit_stream + (n >> 3))) >> k) & 0x1;
}

//----------------------------------------------------------------------------
template <class T>
bool TPatriciaTrie<T>::KeyCompare(const char* key1, const char* key2) const {
    if (!key1 || !key2) {
        return false;
    }
    return (strcmp((char*)key1, (char*)key2) == 0);
}

//----------------------------------------------------------------------------
template <class T>
int TPatriciaTrie<T>::BitFirstDifferent(const char* key1, const char* key2) const {
    
    int         posChar = 0;
    int         posBit = 0;
    
    if (!key1 || !key2) {
        return 0;
    }
    
    while ( (key1[posChar] == key2[posChar]) && (key1[posChar] != 0) && (key2[posChar] != 0) ) {
        posChar++;
    }
    while (BitGet(key1 + posChar, posBit) == BitGet(key2 + posChar, posBit)) {
        posBit++;
    }
    
    return ((posChar << 3) + posBit);
}

//----------------------------------------------------------------------------
template <class T>
TArray<TPatriciaTrieItem<T>*> TPatriciaTrie<T>::ItemList() const {

    TArray<TPatriciaTrieItem<T>*> list;
    TArray<TPatriciaTrieItem<T>*> toCheck;
    toCheck.Push(this->head->right);

    while(!toCheck.IsEmpty()) {

        TPatriciaTrieItem<T>* node = toCheck.Pop();

        if ( node->index < node->left->index ) {
            toCheck.Push(node->left);
        }

        if ( node->index < node->right->index ) {
            toCheck.Push(node->right);
        }
        
        list.Push(node);
    }
    
    return TArray<TPatriciaTrieItem<T>*>(list);
}

//----------------------------------------------------------------------------
template <class T>
TArray<std::string*> TPatriciaTrie<T>::KeyList() const {

    TArray<std::string*> list;
    TArray<TPatriciaTrieItem<T>*> toCheck;
    toCheck.Push(this->head->right);

    while(!toCheck.IsEmpty()) {

        TPatriciaTrieItem<T>* node = toCheck.Pop();

        if ( node->index < node->left->index ) {
            toCheck.Push(node->left);
        }
        
        list.Push(&(node->key));

        if ( node->index < node->right->index ) {
            toCheck.Push(node->right);
        }
    }
    
    return TArray<std::string*>(list);
}

//----------------------------------------------------------------------------
template <class T>
TPatriciaTrieItem<T>* TPatriciaTrie<T>::GetHead() const {
    return head;
}

//----------------------------------------------------------------------------
template <class T>
void TPatriciaTrie<T>::SwapHead(TPatriciaTrie<T>* nTree) {
    
    TPatriciaTrieItem<T>* tmp;
    
    if( head->right != head ) {
        if( nTree->head->right != nTree->head) {
            tmp = nTree->head->right;
            nTree->head->right = head->right;
            head->right = tmp;
        }
        else {
            tmp = head->right;
            head->right = head;
            nTree->head->right = tmp;
        }
    }
    else {
        if( nTree->head->right != nTree->head) {
            tmp = nTree->head->right;
            nTree->head->right = nTree->head;
            head->right = tmp;
        }
    }
    
    return;
}

//----------------------------------------------------------------------------
template <class T>
void TPatriciaTrie<T>::KeyCopy(TPatriciaTrieItem<T>* src, TPatriciaTrieItem<T>* dest) {

    if (src == dest) {
        return;
    }

    dest->key = src->key;
    dest->data = src->data;
}

template class TPatriciaTrie<std::size_t>;
template class TPatriciaTrie<std::string>;
template class TPatriciaTrie<int>;

#include "TFileData.hpp"
template class TPatriciaTrie<TFileData>;

#include "TTokenData.hpp"
template class TPatriciaTrie<TTokenData>;


\end{lstlisting}

Узел дерева Patricia - TPatriciaTrieItem.hpp:
\begin{lstlisting}[language=C++]
#ifndef T_PATRICIA_TRIE_HPP
#define T_PATRICIA_TRIE_HPP

#include <string>

template <class T> class TPatriciaTrie;

template <class T>
class TPatriciaTrieItem {
    private:
        
        friend class TPatriciaTrie<T>;
        
        T                       data;
        std::string             key;
        int                     index;
        TPatriciaTrieItem<T>*   left;
        TPatriciaTrieItem<T>*   right;

    public:

        TPatriciaTrieItem();
        TPatriciaTrieItem(std::string&, T&, int, TPatriciaTrieItem<T>*, TPatriciaTrieItem<T>*);
        virtual ~TPatriciaTrieItem();

        T* GetData();

        void Initialize(std::string, T, int, TPatriciaTrieItem<T>*, TPatriciaTrieItem<T>*);
};

#endif
\end{lstlisting}

Узел дерева Patricia - TPatriciaTrieItem.cpp:
\begin{lstlisting}[language=C++]
#include "TPatriciaTrieItem.hpp"
#include <cstring>
#include <string>
#include <cstdlib>

//----------------------------------------------------------------------------
template <class T>
TPatriciaTrieItem<T>::TPatriciaTrieItem() {
    Initialize(std::string(), T(), -1, this, this);
}

//----------------------------------------------------------------------------
template <class T>
TPatriciaTrieItem<T>::TPatriciaTrieItem(std::string& nKey, T& nData, int nIndex, TPatriciaTrieItem<T>* nLeft, TPatriciaTrieItem<T>* nRight) {
    Initialize(nKey, nData, nIndex, nLeft, nRight);
}

//----------------------------------------------------------------------------
template <class T>
void TPatriciaTrieItem<T>::Initialize(std::string nKey, T nData, int nIndex, TPatriciaTrieItem<T>* nLeft, TPatriciaTrieItem<T>* nRight) {
    key       = nKey;
    data      = nData;
    index     = nIndex;
    left      = nLeft;
    right     = nRight;
}

template <class T>
T* TPatriciaTrieItem<T>::GetData() {
    return &this->data;
}

//----------------------------------------------------------------------------
template <class T>
TPatriciaTrieItem<T>::~TPatriciaTrieItem() {}

template class TPatriciaTrieItem<std::size_t>;
template class TPatriciaTrieItem<std::string>;
template class TPatriciaTrieItem<int>;

#include "TFileData.hpp"
template class TPatriciaTrieItem<TFileData>;

#include "TTokenData.hpp"
template class TPatriciaTrieItem<TTokenData>;
\end{lstlisting}

\pagebreak

