\section{Описание}

Внедрить TF-IDF оказалось не так сложно. Достаточно было сделать в архитектуре следующие изменения:
\begin{enumerate}
    \item в TFileData добавить поле с деревом Patricia, где будут записываться токены и их tf, а также float-переменную, в которую будет записываться итоговый вес.
    \item в TTokenData добавить поле для df.
\end{enumerate}

После этого надо было лишь сделать изменения в работе индекса при добавлении токена и файла, чтобы соответственно обновлять tf и df.

При получении запроса будет также возвращаться список. Однако перед непосредственной отправкой его на веб-сервис осуществляется подсчёт весов TF-IDF. Затем осуществляется сортировка слиянием, и только после этого получаем конечный результат - все файлы с большими весами будут первыми по списку.

Также учтено условие о неточных запросах. Я не знал, что конкретно имелось в виду, поэтому сделал так, что если в запросе нет логических операций, то пробелы между токенами будут восприниматься как логическая операция ИЛИ, а значит списки файлов будут сливаться в один большой. Всё равно ранжирование должно сделать своё дело и выставить на первые строки релевантные файлы.

Если же в запросе есть хотя бы одна логическая операция - поведение будет как при точном запросе, т.е. пробелы между токенами будут работать как при логической операции И.

\pagebreak

\section{Исходный код}

По сути конечная версия исходного кода предоставлена в отчёте к 4 и 3 лабораторным. Не знаю, стоит ли дублировать то же самое и сюда.